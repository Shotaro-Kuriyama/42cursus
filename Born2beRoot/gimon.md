

arch=$(uname -a)

解答
unameでOSのカーネルやマシン情報を表示し、-aオプションで詳細を表示します。



cpuf=$(grep "physical id" /proc/cpuinfo | sort -u | wc -l)

解答
ここでは物理CPUのプロセッサの数を表示します。ここで、物理プロセッサとは
マザーボードに物理的に刺さっているCPU（ソケット）を指します。
一般的なPCでは1つであることが多いですが、環境によっては複数の場合もあります。

物理プロセッサは英語でPhysical CPUといい、この情報は/proc/cpuinfo ファイルに記録されています。

physical id は物理CPU（ソケット）を識別するためのidを表すことが多く、
/proc/cpuinfo には論理CPUごとの情報が並んでいるため、同じ物理CPUに属する場合は
physical id の行が複数回出てきます。

ゆえに、grepでphysical idを探し、
sort -uで重複を含まないようにして、
最後にwc -lでその行数を数えることで
物理CPU（ソケット）の数を求めています。


cpuv=$(grep "processor" /proc/cpuinfo | wc -l)

解答
ここでは仮想CPUのプロセッサの数を表示します。ここで、仮想プロセッサとは
OSから見える論理CPUのことを言います。

物理CPUは基本的に1つであることが多いですが、その物理CPUには、コアやスレッドという概念があります。
例えば、物理CPU一つに対して、コア：4、スレッド：8だったとすると、このとき
物理プロセッサ数：1、仮想プロセッサ数（論理CPU数）：8となります。

これは、物理的な物体としてのCPUは1つであるが、その物理CPUのなかに、
OS上で認識できる8つの論理的なCPUが存在しているということを示します。

仮想プロセッサは英語でVirtual / Logical CPUというので、cpuvというシェル変数に代入しています。
また、物理CPUと違って仮想プロセッサの個数は複数あるため、
ここではsort -uのような重複排除は行わず、
processor行の数をそのまま数えることで論理CPU数を求めています。



ram_total=$(free --mega | awk '$1 == "Mem:" {print $2}')
ram_use=$(free --mega | awk '$1 == "Mem:" {print $3}')
ram_percent=$(free --mega | awk '$1 == "Mem:" {printf("%.2f"), $3/$2*100}')

解答
ここでは利用可能なメモリ（RAM）とその使用率を表示します。
freeというコマンドはメモリの使用状況を表示するコマンドなので、そこから必要な「利用可能なメモリ」と
「メモリ使用率」の情報を上手いこと抜き取っていきます。
total = 利用可能なメモリ
used = 使用しているメモリ
であることから、
「利用可能なメモリ」 = total
「メモリ使用率」 = used/total * 100
なのでこの２つの情報だけで完結します。

まず、freeのみだとKバイト表示で見づらいので--megaオプションを使用してメガバイト表記にします。
そして、 awk（オーク）コマンドを使い、列に対しての操作をします。

awkコマンドは“行ごとに処理して、最後にまとめて出す”
さらにawkの基本として
awk は行を条件で絞って、必要な列だけ抜き出すことができ
$1 = 1列目
$2 = 2列目
$3 = 3列目

と書きます。

awk '$1 == "MeM:"
ここで、1列目がNeM:という文字列の、
{print $3}
3列目を標準出力するということです。

また、Mem