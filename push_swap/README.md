## はじめに

このリポジトリは push_swap を「提出物」ではなく **学習教材**として読めるように整理したものです。

### 前提知識（必須）
- ポインタの基本（`*` / `&` / NULL、関数にポインタを渡す）
- 構造体の基本（メンバアクセス `.` / `->`）
- 単方向連結リストの基本操作（追加/削除/走査）をコードとして理解できる
- コマンドライン引数について（argc, argv**）理解している

### 前提知識（あると理解が速い：推奨）
- malloc/free のエラー処理（途中失敗時にどう片付けるか）
- 計算量の直感（O(n), O(n²), O(n log n)）

---

## この教材で学べること

このコードを読み終えると、次が「説明できる」ようになることを目標にします。

1. **番兵付き双方向（循環）リスト**の設計と、不変条件（invariant）を保つ実装
2. push_swapの命令（sa/pb/ra/...）を **ポインタのつなぎ替え**として実装する方法
3. **入力パースを堅牢にする**（空白、符号、範囲、重複、エラー時の解放）
4. **rank化（座標圧縮）**の目的と実装（値→0..n-1への変換）
5. 小規模（2〜5要素）を **少ない命令で**並べるための考え方（場合分け）
6. **radix sort（基数ソート）**でbitごとに仕分けして並べる考え方（ビット演算を含む）
7. 全体の **計算量**を見積もり、ボトルネックを説明できるようになる

> 補足: 本リポジトリでは「rank化」や「radix」を push_swap の制約に合わせて使います。




# push_swapの概要

push_swapは **「2つのスタック（A, B）と、限られた命令だけで、Aを昇順に並べ替える」** 42のアルゴリズム課題です。

- 入力: 整数列（重複なし）
- 初期状態:  
  - **stack A** に整数列を積む（先頭=topが重要）  
  - **stack B** は空
- 目的: **用意された命令だけ** を出力して、最終的に **Aが昇順**、Bが空の状態にする

> push_swapプログラムは「並べ替えた結果」を表示するのではなく、  
> **並べ替えるための命令列（sa / pb / ra ...）を標準出力に出す** のが仕事です。


## “スタック”ってなに？（push_swap用に最小限で）

ここでのスタックは、ざっくり言うと **「先頭(top)を持つ整数の並び」** です。  
命令は基本的に **先頭(top)周辺** を操作します。

例（左がtop）:
A: [3, 1, 2]
B: []


## 使える命令（何ができるか）

push_swapでは、次の命令だけが許されます（※top側を操作するのが基本）。

- swap: 先頭2つを入れ替える  
  - `sa` / `sb` / `ss`
- push: 片方の先頭をもう片方の先頭へ移す  
  - `pa`（B→A） / `pb`（A→B）
- rotate: 先頭を末尾へ回す（topが1つ進むイメージ）  
  - `ra` / `rb` / `rr`
- reverse rotate: 末尾を先頭へ回す（topが逆に1つ戻るイメージ）  
  - `rra` / `rrb` / `rrr`

この「できることが少ない」制約の中で、
どういう手順（アルゴリズム）なら少ない命令数でソートできるか？が本題です。


# スタックの表現方法（内部実装の話）

重要: **配列でも連結リストでもOK** 
push_swapの評価は「命令列が正しく、かつ少ないこと」であり、内部表現は自由です。

ここでは代表として2つの表現を整理します。


## 1. 配列（contiguous）

配列は **メモリ上に連続して値を持つ** ので、インデックスでアクセスしやすいのが特徴。

- 強み: ランダムアクセスが簡単（a[i]）
- 弱み: 先頭へのpush/popや回転を“配列のシフト”でやるとコストが増えやすい  


## 2. 連結リスト（linked list）

連結リストは **各要素（ノード）が次/前を指すポインタ** を持ち、メモリ上は飛び飛びでも「つながった並び」として扱える。

- 強み: 先頭のpush/pop、回転など「つなぎ替え」で表現しやすい
- 弱み: 配列のように a[i] が簡単ではない（順に辿る必要がある）


## 補足：配列 vs 連結リストの本質的な違い

- 配列: **連続メモリ**（indexで速い、先頭操作は工夫が必要）
- 連結リスト: **非連続メモリ＋ポインタで連結**（先頭操作や回転が表現しやすい、探索は辿る）



## 昇順に並べるということ＝ソート

では、「スタックAに積まれた整数列を昇順に並べよ」という問題は、どのように解くことができるでしょうか？

結論から言うと、これは **ソート（sort）** という、非常に有名で重要な手法（考え方）を使って解きます。

ソートとは、**数値や文字列などのデータを、指定されたルール（基準）に従って昇順（小さい順）や降順（大きい順）に並べ替える操作**のことです。

ただし push_swap は「普通のソート」とは違い、次の制約の中でソートを“実現”する必要があります。
また push_swap では、並べ替えた結果そのものではなく、**並べ替えるための命令列**を標準出力に出力します。

---

## この課題が難しい理由（制約）

### 1. スタックは2つ（AとB）
- 初期状態：スタックAに整数列、スタックBは空
- 目的：最終的に **Aを昇順**、かつ **Bを空** にする

### 2. 使える操作（命令）が決まっている
- 値を直接入れ替えたり、配列を自由に並べ替えたりはできない
- 許された命令だけで並びを動かす必要がある

さらに、push_swapでは **命令数が少ないほど高評価** になるため、
「正しくソートできる」だけでなく「より少ない手数でソートする」工夫が重要になる。

---

## 条件2：ソートに使える命令は以下のみ

push_swapで使える操作は次の命令だけです。

### swap（先頭2つを入れ替える）
- `sa (swap a)`：スタックAの先頭にある最初の2要素を入れ替える  
  要素が1つ以下の場合は何もしない
- `sb (swap b)`：スタックBの先頭にある最初の2要素を入れ替える  
  要素が1つ以下の場合は何もしない
- `ss`：`sa` と `sb` を同時に行う

### push（片方の先頭を、もう片方の先頭へ移す）
- `pa (push a)`：スタックBの先頭要素を取り、スタックAの先頭に置く  
  Bが空の場合は何もしない
- `pb (push b)`：スタックAの先頭要素を取り、スタックBの先頭に置く  
  Aが空の場合は何もしない

### rotate（先頭を末尾へ回す）
- `ra (rotate a)`：スタックAの全要素を1つ上にシフトする  
  最初の要素が最後の要素になる
- `rb (rotate b)`：スタックBの全要素を1つ上にシフトする  
  最初の要素が最後の要素になる
- `rr`：`ra` と `rb` を同時に行う

### reverse rotate（末尾を先頭へ回す）
- `rra (reverse rotate a)`：スタックAの全要素を1つ下にシフトする  
  最後の要素が最初の要素になる
- `rrb (reverse rotate b)`：スタックBの全要素を1つ下にシフトする  
  最後の要素が最初の要素になる
- `rrr`：`rra` と `rrb` を同時に行う

### 表記ルール（このREADME内）
スタックは `[top, ..., bottom]` の順で表記します。
例：A: [3, 1, 2] は、先頭(top)が 3 を意味します。



## 道筋（この教材の進め方）

push_swapは大きく言うと「スタックを作る → 命令を作る → ソートする」課題です。
これをさらに細分化し、次の順番に分解します。

1. 入力処理（文字の入力のされ方）を完成させる  
   - どのような入力を許すか？（コマンドライン引数の受け取り方）
   - 不正入力を確実に弾く（範囲外/重複/空文字など）

2. スタック（データ構造）を完成させる  
   - 今回は番兵付き双方向循環リストを使用します。

3. 命令（sa/pb/ra/...）を実装する  
   - 命令はデータ構造に依存するため、番兵付き双方向循環リストに基づいて実装する。

4. 小規模ソート（2〜5個）で手順設計に慣れる

5. rank化（座標圧縮）で値を 0..n-1 に変換する

6. radixなどの大規模ソートで全体を完成させる

7. 命令数を計測し、改善する（発展）


## 1, 入力処理

文字入力のされ方について、以下のような4つの場合に分けられます。

1. ダブルクォーテーションがない
./push_swap 2 1 4 3

2. ダブルクォーテーションがある
./push_swap "2 1 4 3"

3. ダブルクォーテーションが複数ある
./push_swap "2 1" "4 3"

4. 融合している
./push_swap "2 1" "3 5" 4 6 "9"

目標は、これら全てのパターンにおいて、この文字列（char型）をint型に変換し
スタックaに積まなければなりません。
イメージ
スタックa→[2, 1, 4, 3]

まずは1と2の構造について理解することが必要です。

### パターン1
./push_swap 2 1 4 3

スタックa→[2, 1, 4, 3]

これはint argc = 5

となるときで、**argvが以下のような構造になるときである。
**argvが4つのそれぞれの文字列の先頭変数のメモリを参照している。
つまり、argv[1]~argv[4]まで存在する。

これをスタックに積むためには？
文字列の数字部分だけを取り出して、int型に変換する関数に渡せば必要がある。



char **words  ───────────────▶  +---------------------------+
                                 | words[0] | words[1] | ...| words[n]=NULL |
                                 +----+-----------+--------+------------------+
                                      |           |
                                      v           v
                                  "2\0"      "1\0"     ...


### パターン2
./push_swap "2 1 4 3"

スタックa→[2, 1, 4, 3]

これはint argc = 2

となるときで、**argvが1つ文字列を参照し、その文字列に複数の数字が羅列されている。
つまり、argv[1]が存在する。


#### パターン4
./push_swap "2 1" "3 5" 4 6 "9"

スタックa→[2, 1, 3, 5, 4, 6, 9]

これはint argc = 6

この場合の図は以下のようになる
ここでは、わかりやすいように全てのargv[]が参照する文字列を書き出すと
argv[1] = "2 1"
argv[2] = "3 5"
argv[3] = "

(mainのスタックフレーム)
  argc = 6
  argv (char**)  ───────────────▶  argv配列（char*の配列, NULL終端）
                                  +------------------------------------+
                                  | argv[0] | argv[1] | ... | argv[5] | argv[6]=NULL |
                                  +----+--------+--------+------+-----+-------------+
                                       |        |        |      |     |
                                       v        v        v      v     v
                                   "./push_swap\0"
                                            "2 1\0"
                                                     "3 5\0"
                                                            "4\0"
                                                                 "6\0"
                                                                      "9\0"


パターン2において、argv[i] が "2 1" や "3 5" みたいに 複数入りが混ざる
→ だから各 argv[i] を さらに split して 数を取り出す

ここから、目的→戦略→手順→失敗時→結果の順に明確にしていく。


## １、スタック作成

まず、スタックを何で作るかという部分が重要である。
今回は配列ではなく連結リストを用いてスタックを作成していくとすると、
基本的に連結リストの作り方は一つに限らない。
例えば、
単方向リスト
→*nextのポインタのみ持ち、一方向にしかいけない。
双方向リスト
→*next と *prevもポインタを持ち双方向に移動できる。

今回使うのは、双方向リストを使うことにする。
さらに学習のためにより応用的な
**番兵つき双方向リスト**でスタックaを作成していく。

それ以外に重要なものがある。
それは、文字の入力のされ方である。
そこには大きな場合分けが２つ

#### パターン１
./push_swap 2 1 4 3

スタックa→[2, 1, 4, 3]

これはint argc = 5

となるときで、**argvが以下のような構造になるときである。
ただし、この図はヒープにmallocしている変数に入れることを前提としている。
argvは「OS/ランタイムが用意して渡してくれる、文字列ポインタ配列」
自分ではmallocしていない領域

(スタック)                          (ヒープ)
char **tokens  ───────────────▶  +---------------------------+
                                 | tokens[0] | tokens[1] | ...| tokens[n]=NULL |
                                 +----+-----------+--------+------------------+
                                      |           |
                                      v           v
                                  "2\0"      "1\0"     ...


#### パターン２
./push_swap "2 1" "3 5" 4 6 "9"

スタックa→[2, 1, 3, 5, 4, 6, 9]

これはint argc = 6

この場合の図は以下のようになる

(mainのスタックフレーム)
  argc = 6
  argv (char**)  ───────────────▶  argv配列（char*の配列, NULL終端）
                                  +------------------------------------+
                                  | argv[0] | argv[1] | ... | argv[5] | argv[6]=NULL |
                                  +----+--------+--------+------+-----+-------------+
                                       |        |        |      |     |
                                       v        v        v      v     v
                                   "./push_swap\0"
                                            "2 1\0"
                                                     "3 5\0"
                                                            "4\0"
                                                                 "6\0"
                                                                      "9\0"


パターン2において、argv[i] が "2 1" や "3 5" みたいに 複数入りが混ざる
→ だから各 argv[i] を さらに split して 数を取り出す

ここから、目的→戦略→手順→失敗時→結果の順に明確にしていく。



1. 目的（最終的に何を作るか）
コマンドライン引数に含まれる数字をすべて読み取り、
不正入力（空、非数、範囲外、重複）を弾き、
正しい整数だけを スタックA（連結リスト）に順番通りに積む。

2. 戦略（パターン1/2をどう統一するか）
引数の形式は2種類ある。
・パターン1：2 1 4 3 のように 1引数 = 1数
・パターン2："2 1" のように 1引数 = 複数数（空白区切り）
しかし今回は処理を分岐させず、すべての argv[i] を split してから処理することで統一できる。

1数なら split 結果は ["2", NULL]

複数なら ["2","1",NULL]

つまり、入力は最終的に「文字列トークン列（tokens）」へ正規化される。

3. 手順（外側ループ→内側ループ）
i = 1 から argc-1 まで各引数 argv[i] を順番に処理する（外側ループ）
それぞれを split_ws(argv[i]) で分割し tokens を得る
tokens[j] を先頭から順に見ていき（内側ループ）、
・厳密に int に変換できるか
・既にスタックAに同じ値がないか
・ノード作成に成功するか
を確認してから push_back で追加する

4. エラー条件と後始末（ここがpush_swapで超大事）
split_ws が失敗 → メモリ不足など → 今まで作ったリストも含めて解放して終了
tokens[0] がない（空白だけなど） → Error
数値変換が失敗（非数、オーバーフロー含む） → Error
重複がある → Error
ノード確保に失敗 → Error
正常時は free_split(tokens) を毎回行い、最後に free_list(a) で全解放する

まとめ
このプログラムは、コマンドライン引数から整数列を読み取り、スタックA（連結リスト）に積む。
入力形式には「各数字が別引数で渡される場合」と「1つの引数に空白区切りで複数数字が含まれる場合」があるが、両方を同じ処理で扱うために、argv[i] を毎回 split_ws で分割して tokens（文字列の配列）に正規化する。
外側ループで i=1 から argc-1 までの各引数を順に処理し、内側ループで tokens[j] を先頭から取り出して数値化する。
各トークンは parse_int_strict_by_atoi で厳密に int へ変換し、変換できない文字列・範囲外の値は Error とする。ささらに contains で重複を検出し、重複があれば Error とする。
問題ない値は new_node でノードを作って push_back でスタックAの末尾に追加する。
途中でエラーが起きた場合は、それまでに確保したリストや split の結果を解放して終了する。正常に処理できた場合は、スタックAには入力順に整数が積まれる。

この入力処理は「正規化 → 検証 → 構築」の3段階
正規化：split_ws(argv[i])
検証：parse_int_strict / contains
構築：new_node / push_back

2. スタックをソートするための命令群を作る。

これは本当二ただそのまま再現するだけ




##　座標圧縮のやり方

### 1 スタックでそのままやる（計算量O(n²))

必要なことは、先頭ノードから初めて、
そのノードのvalueよりも小さい数がなんこあるのか、
全てのノードで毎回確認する。

### 2 速いソートで昇順にしてから二分探索で高速に（計算量O(n log n))


1) マージソートって何？
目的

配列（数の並び）を 小さい順に並べ替えるソートの一種です。

発想（超ざっくり）

「大きい問題を小さくして、最後に合体する」

配列を 真ん中で2つに割る

左半分をソートする

右半分をソートする

ソート済みの左と右を “マージ（merge=合体）”して1つのソート済み配列にする

“マージ”のイメージ（ここが核心）

すでにそれぞれ 昇順になっている2列を、先頭から比べて小さい方を順に取り出すだけです。

例：

左：[1, 4, 9]

右：[2, 3, 10]

手順：

1 と 2 → 1 を出す

4 と 2 → 2 を出す

4 と 3 → 3 を出す

4 と 10 → 4 を出す

9 と 10 → 9 を出す

残りの 10 を出す

結果：[1,2,3,4,9,10]

なんで速いの？

分割は “半分、さらに半分…” と進むので深さが log2(n) 程度。
各段でマージは全要素を1回ずつ触るので n。
よって全体で O(n log n) になります。

2) 二分探索って何？
目的

ソート済み配列から、ある値が “どこにあるか” を高速に探す方法です。

発想

「真ん中を見て、左か右かを捨てる」を繰り返す。

例：ソート済み [-3, 1, 7, 42, 99] から 42 を探す

真ん中を見る（7） → 42は大きい → 左半分は全部捨てて右へ

右側の真ん中を見る（42） → 発見

なんで速いの？

毎回探索範囲が半分になるので、回数は log2(n) 回程度。
よって O(log n)。

3) マージソート＋二分探索で「座標圧縮」をする考え方

あなたがやりたい座標圧縮は結局これです：

全ての値を集める

それを ソートして「小さい順の一覧」を作る

各値について「一覧の何番目か」を調べて rank にする
→ この「何番目か」を 二分探索で高速に調べる

##　今のところやらないといけないこと


2) 次にやる：rank化（座標圧縮）を入れる（大入力の前提）

chunk / radix どっちに進むにしても rank はほぼ必須級です。

やることはシンプルで：

Aの全valueを配列にコピー

その配列をソートした “sorted配列” を作る

各ノードvalueを「sortedの何番目か」に変換（0..n-1）

こうすると、値が -10 とか 1000000 とかでも関係なく、扱うのは 0..n-1 だけになります。
chunkが「範囲（例 0〜19）」で切れるのはこれのおかげ。

※この段階は “配列ソートの知識” と push_swap が繋がる最高の学習ポイントです。

3) 大きい入力の最初の完成形：まずは radix をおすすめ（実装が素直）

学習効率で言うと、

radix：実装がきれい、バグらせにくい、正しさの理解がしやすい

chunk：回転最適化・戦略設計が必要で学びが多いが、まずは土台がいる

なので、rank化 → binary radix を1回通すのが強いです。

ラフな流れ（rankで動かす）：

bit=0,1,2... と見ていく

Aの先頭のbitが0なら pb、1なら ra

n回やったら pa でBを戻す

次のbitへ

これでちゃんとソートできます（比較してないのに）。

4) その次：chunkに進む（あなたがやりたい“範囲で分ける”）

radixで「分類して運ぶ」感覚が掴めたら、chunkはこう理解できるようになります：

radix：bitで分類（0/1）

chunk：rankの範囲で分類（例 0〜19 / 20〜39 / ...）

ここまで来ると、chunkの改良ポイント（回転最小化、Bの整形、rr/rrr合体）が学習として美味しいです。

いまのあなたの「次のTODO」まとめ（最短で伸びる順）

min_index 修正（empty対応 + int型）

is_sorted_asc を作って、最初に return する

sort2/sort4 を作って solve_small 完成

rank化（座標圧縮）

radixで大入力をまず完成（100/500が動く状態）

chunkに発展（回転最適化で手数を減らす）




## 整理

今ランク化するためのコードを理解する。
二分探索なども出てくる。

構造体にrank変数を作ったので、そちらのコードに作り変える。


1/5/20;00
次はnormのための関数分割

