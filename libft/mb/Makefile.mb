まず、Makefileの超基礎

ターゲット（all や clean など）
「この名前の作業をやるよ」というラベル。

依存関係（prerequisites）
ターゲットを作る前に「これらが必要」という入力ファイル（例：.o ができてから libft.a を作る）。

レシピ（実行コマンド）
ターゲットを作るために実行するシェルコマンド。行頭はタブ必須！

型：

ターゲット: 依存ファイル1 依存ファイル2 ...
<TAB>コマンド

変数
CC=cc のように設定しておき、$(CC) と書いて使い回す。

.PHONY
「これは実ファイルじゃなくて“名前のラベル”です」と宣言して衝突を避ける。



NAME    = libft.a                 # 生成する静的ライブラリのファイル名（出力物）

CC      = cc                      # Cコンパイラ（clangやgccの抽象名。42はcc想定でOK）
CFLAGS  = -Wall -Wextra -Werror   # 警告+エラー化のフラグ（必須級）
AR      = ar rcs                  # .oをまとめてアーカイブにするコマンド（r=追加, c=新規作成, s=索引）
RM      = rm -f                   # ファイル削除コマンド（-fでエラー抑止）

# mandatory部分のソース(.c)一覧。行末の「\」は改行継続（次の行も同じ行として扱う）
SRCS = ft_isalpha.c ft_isdigit.c ft_isalnum.c ft_isascii.c ft_isprint.c \
       ft_strlen.c ft_memset.c ft_bzero.c ft_memcpy.c ft_memmove.c \
       ft_strlcpy.c ft_strlcat.c ft_toupper.c ft_tolower.c \
       ft_strchr.c ft_strrchr.c ft_strncmp.c ft_memchr.c ft_memcmp.c \
       ft_strnstr.c ft_atoi.c ft_calloc.c ft_strdup.c \
       ft_substr.c ft_strjoin.c ft_strtrim.c ft_split.c ft_itoa.c \
       ft_strmapi.c ft_striteri.c ft_putchar_fd.c ft_putstr_fd.c \
       ft_putendl_fd.c ft_putnbr_fd.c

# bonus部分のソース一覧（リスト系）
BONUS_SRCS = ft_lstnew.c ft_lstadd_front.c ft_lstsize.c ft_lstlast.c \
             ft_lstadd_back.c ft_lstdelone.c ft_lstclear.c ft_lstiter.c ft_lstmap.c

# 上で列挙した .c の拡張子を .o に置き換えたリストを作る（Makeの置換展開）
OBJS       = $(SRCS:.c=.o)
BONUS_OBJS = $(BONUS_SRCS:.c=.o)

# 「make」とだけ打ったときに最初に実行されるデフォルトのターゲット
# $(NAME) を作れ、という意味（＝libft.aを作る）
all: $(NAME)

# libft.aを作るルール：依存（前提）として .o 一式が必要
$(NAME): $(OBJS)
	$(AR) $(NAME) $(OBJS)   # アーカイブ作成。ここはTABで始まる「レシピ」行！

# bonusターゲット：mandatoryの.o も bonusの.o も両方作って、同じlibft.aに詰める
bonus: $(OBJS) $(BONUS_OBJS)
	$(AR) $(NAME) $(OBJS) $(BONUS_OBJS)

# パターンルール：「任意の%.oは、対応する%.cからこうやって作る」という一般則
%.o: %.c
	$(CC) $(CFLAGS) -I. -c $< -o $@
#  -I.   : カレントディレクトリをヘッダ探索に追加（"./libft.h" を見つけてもらう）
#  -c    : コンパイルのみ（リンクせず .o を出力）
#  $<    : 依存ファイルの先頭（ここでは対応する .c ファイル）
#  -o $@ : 出力ファイル名をターゲット名（ここでは .o）にする
#  ※この行もTABで始まる必要あり

# 中間生成物の掃除（.oを消す）。bonusの.oも忘れずに消す
clean:
	$(RM) $(OBJS) $(BONUS_OBJS) 

# 生成物の完全掃除：まずclean（.o削除）を実行し、その後ライブラリ本体も削除
fclean: clean
	$(RM) $(NAME)

# 作り直し（ふきだし）：fcleanで全削除 → allで再ビルド
re: fclean all

# これらのターゲット名は「実ファイルではなく命令ラベルですよ」という宣言
# ファイル名とターゲット名の衝突を避け、毎回必ず実行されるようにする慣習
.PHONY: all clean fclean re bonus 