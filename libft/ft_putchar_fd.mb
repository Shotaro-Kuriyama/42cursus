ft_putchar_fd は一見「ただ1文字出力するだけ」なので地味に見えますが、この課題はlibcの基礎中の基礎を体感で理解させるためのものです。
学べることは、思っている以上に深いです。

🧠 学べる本質
1. 「標準出力」と「ファイル記述子(fd)」の仕組み

普段 printf("Hello"); と書くだけで画面に出るけど、
実際には OS の「ファイル記述子 (file descriptor)」という仕組みを使って
文字を出力していることを学びます。

| 出力先                | ファイル記述子番号 |
| ------------------ | --------- |
| 標準入力 (keyboard)    | 0         |
| 標準出力 (terminal)    | 1         |
| 標準エラー出力 (error表示用) | 2         |


つまり：

write(1, "A", 1); // 標準出力（画面）
write(2, "E", 1); // 標準エラー出力

というように、OSレベルで出力先を指定できることを理解します。

→ これは、後のプログラミングで「ログ出力」「ファイル出力」「リダイレクト」「パイプ処理」を理解する基盤になります。

2. write() システムコールの使い方

write は C 言語標準ライブラリではなく、UNIXのシステムコール（カーネルに直接命令を出す関数）です。

プロトタイプは：

ssize_t write(int fd, const void *buf, size_t count);

→ 「fd に、buf の中身を count バイト書き込め」

これを使うことで、
「C言語の裏側では、printf なども実は write() を通じて出力している」
ということを実感できます。

3. メモリとポインタの扱いの基礎

write(fd, &c, 1);

&c は「文字変数 c のアドレス（＝メモリ上の位置）」。

write() はその「場所」から1バイト分のデータを読み取って出力する。

つまりここで、
「アドレス渡し」「メモリの中身を扱う」というC言語の基本操作を体験します。

4. 標準入出力を抽象化して考える力

「出力先」を固定せずに「fd」という引数にしたことで、
同じ関数で、ターミナルにもファイルにも出力できる設計になっています。

この「出力先を抽象化する」という設計思想は、
後に学ぶ関数（ft_putstr_fd, ft_putendl_fd, ft_putnbr_fdなど）や
より大きなプログラム構造にも通じます。

5. 小さくても「ライブラリ」としての意識

libft は最終的に「自分の mini 標準ライブラリ」を作る課題です。
ft_putchar_fd はその中の1つ。

つまり、自分の関数群を積み重ねて再利用できる形で構築するという
ライブラリ設計の第一歩でもあります。

💡 まとめ：この課題の本質的な学び

| 観点        | 学べること                     |
| --------- | ------------------------- |
| OSとC言語の関係 | 出力は「システムコール」を通じて行われる      |
| 抽象化設計     | 出力先を「fd」で抽象化して柔軟性を持たせる    |
| メモリの扱い    | `&c` でポインタ渡しを理解する         |
| 実践的出力制御   | 標準出力・標準エラー・ファイル出力を統一的に扱える |
| ライブラリ構築   | 再利用できる関数を積み上げていく設計意識を養う   |



void	ft_putchar_fd(char c, int fd)
{
	(void)write(fd, &c, 1);
}

なぜvoidにキャストしなければならないのか？


いい質問！(void)write(fd, &c, 1); の (void) キャストには、主に次の意味があります。

何のために (void) を付けるの？
1) 「返り値を意図的に捨てています」という宣言

write() は ssize_t（書けたバイト数 or エラーなら -1）を返します。
でも ft_putchar_fd の仕様は 戻り値なし（void） で「1文字を書くだけ」。
この場面では返り値を使わないので、明示的に捨てるために (void) を付けます。

ただ write(fd, &c, 1); と書いても動きは同じですが、
(void) を付けると「無視は意図的」と読み手＆リンタに伝わります。

2) 警告を抑える（リンタ/規約対策）

コンパイラやリンタの設定次第では、返り値を使っていないことに警告が出る場合があります。
(void) を付けるのは、そうした警告に対して
「ここは意図的に未使用」と示す、C の慣用的なやり方です。

例：-Wunused-result 系の警告を出すツール/設定がある

42 の Norm・静的解析ツールでも好まれる書き方です

3) 「読み手への親切」＝コードの意図が一目でわかる

チーム開発では、ただの write(...) だと「返り値チェックを忘れてる？」と誤解されがち。
(void) があると「この関数の責務ではチェックしない方針」と 設計意図が伝わる ので読みやすいです。

そもそも write() の返り値って何？

ssize_t write(int fd, const void *buf, size_t count);

戻り値 = 実際に書けたバイト数（正常系）

-1 = エラー（例：無効な fd、パイプ切断、ディスク満杯、権限なし、EINTR など）

本気で堅牢にやるなら、本来は返り値をチェックして

エラーなら処理を中断・報告

部分書き込み（count の一部しか書けない）なら、残りをループで再試行
とします。

じゃあ、なぜ libft では捨ててもいいの？

課題の仕様が void ft_putchar_fd(char c, int fd)（返さない）だから

さらに 1 バイトだけの書き込みで、しかも学習目的のミニ関数

実務並みの堅牢性よりも、システムコールの使い方を掴むのが主目的

だから「返り値はこの関数の責務外、上位で必要に応じて対応してね」という前提の設計にして、ここでは (void) で明示的に捨てるのがスッキリします。