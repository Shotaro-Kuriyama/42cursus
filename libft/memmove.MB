なぜ「dst>src の重なり」で後ろから？

前提：重なりがあって dst = src + shift（0 < shift < n）だとします。
memcpy風に前からコピーすると各ステップでやっていることは：

for (i = 0; i < n; i++)
    dst[i] = src[i];   // つまり src[i+shift] = src[i]

ここで問題が起こるのは、まだ読んでいない src[i] が、過去の書き込みで上書きされてしまうから。

i を進めていくと、ある時点で i = j + shift となる j が存在します（重なっているので必ず起こる）。

その少し前、ステップ j で私たちは src[j+shift] に書き込みました。
でも src[j+shift] は今まさに読みたい src[i] そのもの（なぜなら i = j+shift）。

つまり、読みたい元データ src[i] を、過去の自分の書き込みで潰してしまっている。これが破綻点。

図にすると：

src: [ s0 s1 s2 s3 s4 s5 ]
dst:       [ s0 s1 s2 s3 s4 s5 ]   // shift = 3, dst = src+3
前からやると…
i=0: 書先=src[3] ← 読元=src[0] を書く   (OK)
i=1: 書先=src[4] ← 読元=src[1] を書く   (OK)
i=2: 書先=src[5] ← 読元=src[2] を書く   (OK)
i=3: **読元=src[3] を読みたいが、i=0で既に上書き済み** → 壊れる


要するに**依存関係（read-after-write hazard）**が発生するんです。

後ろからならなぜ安全？

後ろからやると：

for (i = n; i-- > 0; )
    dst[i] = src[i];   // つまり src[i+shift] = src[i]


この順序だと、これから読む src[i] よりも“高いアドレス側”にだけ書いていくことになります。
だから、これから読む位置 src[i] は、まだ一度も上書きされていない＝常に“生の元データ”を読める。

図（同じ shift=3）：

i=5→3 の順で先に処理：書き込み先は src[8]→src[6]。どれも “読元より右側”。
次に i=2→0 を処理するとき、src[2],src[1],src[0] はまだ無傷。安全に読める。

まとめ（短く）

重なり & dst>src では、前からコピーすると未読の元データを自分で上書きしてしまう。

後ろからコピーなら、これから読む場所はまだ触っていないので安全。

これは理屈で必然。慣習や「決まり文句」ではありません。

memmove はこの必然に従って、dst<src なら前から／dst>src なら後ろから、と方向を切り替えるだけの話です。

（※ 一時バッファに丸ごと退避→前から書き戻す、でも同じく安全。ただし余分なメモリが要るので、多くの実装は「方向切替」を使います。）