「ノード」「構造体」「node->content = content; の意味」まで、超ゼロからいきます。ゆっくり読めば必ず腑に落ちます。

ノードってなに？

たとえば「電車の車両」を想像してください。

1両（＝ノード）の中に「荷物（＝content）」が入っていて、

次の車両へつながる「連結器（＝next）」が付いています。

車両が1両だけなら連結器は何にも繋がらない＝NULL。
複数つなぐと「連結リスト（Linked List）」になります。

[ ノードA ] --next--> [ ノードB ] --next--> [ ノードC ] --next--> NULL
     |                      |                      |
  content                 content                 content




構造体（struct）入門

構造体は「複数の値をひとまとめにして、新しい型を作る」仕組みです。

// 例：点を表す構造体
struct s_point {
    int x;
    int y;
};

struct s_point p; // 変数pを作る
p.x = 10;         // ドットでメンバにアクセス
p.y = 20;

構造体へのポインタがあるときは -> を使います。

struct s_point *pp;
pp = &p;
pp->x = 30;       // (*pp).x と同じ意味

覚え方

変数そのもの：.

変数へのポインタ：->（「矢印」は「ポインタから辿る」イメージ）




t_list の正体（libft のノード型）

libft では、ノードを表す構造体をこう定義します（libft.h に置く）：

typedef struct s_list {
    void            *content; // データ本体へのポインタ（型は何でもOK）
    struct s_list   *next;    // 次のノードへのポインタ（なければ NULL）
} t_list;


content は void *（なんでも指せるポインタ）。
文字列でも、整数へのポインタでも、構造体でもOK（※使うときはキャストする）。

next は 次のノードへのポインタ。末尾は NULL。

typedef ... t_list; により、以後 t_list という別名の型で使えます。



ft_lstnew の2行を理解する

node->content = content; // 中身はコピーしない。「そのポインタ」を持つだけ
node->next = NULL;       // 新規ノードは単体なので次は NULL

node->content = content;

content は **アドレス（ポインタ）**です。

「データ本体」をコピーするのではなく、そのデータがある場所の住所（ポインタ）をノードにそのまま保存します。

だから 同じメモリを共有します。元データを書き換えれば、ノードから見ても反映されます。

例：

char *s = "Hello";           // 文字列リテラルの先頭アドレス
t_list *node = ft_lstnew(s); // node->content は s と同じアドレスを指す


これを「浅い代入（浅いコピー）」と言います。
新しいメモリに複製を作る「深いコピー」は ft_lstnew はしません。

node->next = NULL;

作ったばかりのノードは まだ誰とも繋がっていないので、次はありません。

そこで 「次はない」＝ NULL を入れておきます。

これが終端の印になり、ループ処理で「ここで終わりだ」と判定できます。


