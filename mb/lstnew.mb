いいね、いよいよ「ボーナス」パートのリスト操作です。まずは最初の関数 ft_lstnew を、超初心者向けにサクッと理解→実装→テストまで一気にいきましょう。

そもそも「連結リスト」とは？

配列：メモリ上に連続に並ぶ。途中で要素を挿入/削除が苦手（ずらす必要あり）。

連結リスト：各要素（ノード）が「次のノードへのポインタ」を持ち、チェーンのように繋がる。途中挿入/削除が得意。

今回のノード型（必ず libft.h に入れる）：

typedef struct s_list
{
	void            *content; // データ本体へのポインタ（型は何でもOK）
	struct s_list   *next;    // 次のノードへのポインタ（末尾なら NULL）
} t_list;


ft_lstnew でやること

「新しいノードを1個だけ作って返す」関数です。

malloc で t_list の分だけメモリを確保

node->content に 引数でもらったポインタ をそのまま入れる
※中身のコピーはしない

node->next は 必ず NULL に初期化

失敗したら NULL を返す

実装例（42の規約的にもOKな最小限）

libft.h（一部）

#ifndef LIBFT_H
# define LIBFT_H
# include <stddef.h>

typedef struct s_list
{
	void            *content;
	struct s_list   *next;
}	t_list;

t_list	*ft_lstnew(void *content);

#endif

ft_lstnew.c


#include <stdlib.h>
#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*node;

	node = (t_list *)malloc(sizeof(t_list));
	if (!node)
		return (NULL);
	node->content = content; // 中身はコピーしない。「そのポインタ」を持つだけ
	node->next = NULL;       // 新規ノードは単体なので次は NULL
	return (node);
}


よくある疑問＆落とし穴
Q1. content は「値」じゃなくて「ポインタ」なの？

はい。void * なので 「何型でも指せるポインタ」 を想定しています。
ft_lstnew は“ノードを作るだけ” で、データの確保やコピーはしません。

例1：文字列リテラルを指す → 解放しない（解放すると危険）

例2：malloc したメモリを指す → リストを片付ける時は自分で freeが必要

Q2. ローカル変数（スタック変数）を指してよい？

ダメです。関数を抜けると消えるのでダングリングポインタになります。
整数を入れたいなら、ヒープに確保してからそのアドレスを渡しましょう。


int *n = malloc(sizeof(int));
*n = 42;
t_list *node = ft_lstnew(n); // OK


Q3. next を NULL にし忘れると？

後でリスト操作（末尾判定など）で未初期化メモリにアクセスする危険があります。必ず NULL に。

使い方ミニ例
文字列を入れる（文字列リテラル）

#include <stdio.h>
#include "libft.h"

int main(void)
{
	char   *s = "Hello";
	t_list *n = ft_lstnew(s);

	printf("%s\n", (char *)n->content); // キャストして取り出す
	// s は文字列リテラルなので free しない
	free(n); // ノード自体は free する
	return 0;
}

#include <stdlib.h>
#include <stdio.h>
#include "libft.h"

int main(void)
{
	int    *p = (int *)malloc(sizeof(int));
	t_list *n;

	if (!p)
		return 1;
	*p = 42;
	n = ft_lstnew(p);
	if (!n)
	{
		free(p);
		return 1;
	}
	printf("%d\n", *(int *)n->content);
	// 片付け：中身を自分で確保したなら中身→ノードの順で free
	free(n->content);
	free(n);
	return 0;
}

ルール：「誰が確保したか」が解放の責任。
ft_lstnew は 中身を確保していない ので、中身の解放はあなたの責任です。


メモリの頭の中イメージ

[ノード(node)]
+--------------------+
| content -> (何か)  |----> 例えば "Hello" の先頭アドレス
+--------------------+
| next    -> NULL    |    （まだ1個だけなので次は無し）
+--------------------+


