




get_next_lineの前提

openとreadについてわからないと何もわからん。

ファイルディスクリプタ (fd)：OSがファイルを識別する“番号”。
標準入力=0、標準出力=1、標準エラー=2。open()で新しいfd（0,1,2以外の整数）が返る。
エラーのときはだいたい -1 が返り、理由は errno に入る（perror()やstrerror(errno)で表示）。


open の基本

#include <fcntl.h>   // open, O_RDONLY など
#include <unistd.h>  // close
#include <errno.h>   // errno
#include <stdio.h>   // perror

int fd = open("test.txt", O_RDONLY);
/* 成功: 0以上（例: 3 など）
   失敗: -1（例: ファイル無し→ENOENT）*/
if (fd == -1) {
    perror("open");
    /* ここで終了でもOK */
}



主なフラグ

O_RDONLY 読み取り専用

O_WRONLY 書き込み専用

O_RDWR 読み書き両方

O_CREAT 無ければ作る（第3引数にパーミッションが必須）

O_TRUNC 既存ファイルを長さ0に

O_APPEND 末尾に追記モード


/* 例: 書き込み用に「無ければ作る・あれば中身を空に」
   rw-r--r-- (0644) で作成 */
int fd = open("out.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

第3引数の「0644」は新規作成時のパーミッション。
先頭の 0 は8進数リテラルの印。

終わったら 必ず close(fd)。


read の基本

#include <unistd.h>  // read
#include <sys/types.h> // ssize_t

ssize_t n = read(fd, buf, bufsize);
/* 戻り値:
   >0  読めたバイト数（要求より小さいことも普通にある）
    0  EOF（終端）
   -1  エラー（errno参照; EINTR/EAGAINなど） */


ポイント：

部分読みは普通に起きるので、欲しいサイズ分ループで読む（特にソケット/パイプ）。

文字列として扱いたいなら 自分でヌル終端（buf[n] = '\0'）が必要。

EINTR（シグナル割込み）なら もう一度 read し直すのが定石。

ノンブロッキングやパイプで EAGAIN/EWOULDBLOCK の可能性もある（今回は深追い不要）。

4) いちばん初歩のサンプル（ファイルを開いて読んで標準出力へ）

test.txt を作ってから試してください（エディタでOK）。

// read_hello.c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>

int main(void) {
    int fd = open("test.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    char buf[128];
    while (1) {
        ssize_t n = read(fd, buf, sizeof buf);
        if (n > 0) {
            /* 文字列ではなく「生のバイト列」なので、そのままwriteで出す */
            ssize_t w = write(1, buf, n); // 1はSTDOUT
            if (w == -1) { perror("write"); close(fd); return 1; }
        } else if (n == 0) {
            /* EOF */
            break;
        } else {
            /* n == -1: エラー */
            if (errno == EINTR) continue;  // もう一回やる
            perror("read");
            close(fd);
            return 1;
        }
    }

    close(fd);
    return 0;
}


