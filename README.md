# push_swapの概要

まず何をする？
→push_swapは、「限られた命令だけでスタックを並べ替える」アルゴリズム課題
整数列を、スタックaに積んで開始し、もう一つのスタックbは空とする。
用意された命令（sa/sb/ss/pa/pb/ra/rb/rr/rra/rrb/rrr）だけで、aを昇順に並べる。

じゃあスタックってなに？
スタックとはデータを積み上げるということである。
今回の場合は、整数列（21,312,1,5,4325235,2424,42）をスタックaに積み上げる
→大きな箱に一個一個データを入れていく
つまりスタックaは、言い換えればデータの構造であるということ。
よってスタックaの表現方法は一つに限らない。

## スタックの表現方法

まずスタックを視覚化すると以下のようになる。
a: [3, 1, 2]

ここから、「スタックである」ための条件は
1, データが繋がっている、または、連結されている。
２, 繋がっているデータは入れ替え可能である。

これらを満たす。
よって少なくとも以下の２つの表現方法がある。

### 1、配列
配列は
とあるメモリのアドレスを筆頭に**隣合わせでデータ（変数）**が連なる。
よって、データが連結されている。
このことから、繋がっているデータは入れ替え可能である。

### 2、連結リスト
連結リストは
あるメモリに格納されている一つのデータ（構造体）と、
更に別にあるメモリに格納されている一つのデータ（構造体）を
**一つのデータ群（構造体）＝ノード**という形で連結して持つことができる。
よってデータも入れ替え可能。

### 補足
この２つの違いはデータ構造がメモリを隣合わせで持つのか、飛び飛びのメモリから
それらをポインタを利用してデータ構造として連なるのか、という違いがある。
これが配列と連結リストの大きな違いである。



##　昇順に並べるということ＝ソート

では、「スタックaに積まれた整数列を昇順に並べよ」という問題は
どのように解くことができるか？
これはソートという超有名で重要な手法を用いる

ソートとは
**数値や文字列などのデータを、指定されたルール（基準）に従って昇順（小さい順）や降順（大きい順）などに並べ替える操作のことです。これは、データを効率的に検索・処理・表示するために不可欠な基本機能で、ソートアルゴリズム（バブルソート、クイックソートなど）を用いて実装され、多くのプログラミング言語で標準機能として提供されています。**

##　結論
以上から、
スタックaのデータを昇順に並べるためにはソートを用いる。
ただし、今回の課題は以下の２つの条件が存在する。

### 1、スタックb

◦ スタック a には、負の数と正の整数がランダムな個数含まれている。
◦ スタック b は空です。

### 2、ソートをするために使用できる命令は以下のものだけである。

sa (swap a): スタック a の先頭にある最初の 2 要素を入れ替える。
要素が1つしかない場合、または要素が存在しない場合は何もしない。

sb (swap b): スタック b の先頭にある最初の 2 要素を入れ替える。
要素が1つしかない場合、または要素が存在しない場合は何もしない。

ss : sa と sb を同時に行う。

pa (push a): b の先頭要素を取り、a の先頭に置く。
bが空の場合、何もしない。

pb (push b): a の先頭要素を取り、b の先頭に置く。
aが空の場合、何もしない。

ra (rotate a): スタック a の全要素を 1 つ上にシフトする。
最初の要素が最後の要素になる。

rb (rotate b): スタック b の全要素を 1 つ上にシフトします。
最初の要素が最後の要素になる。

rr : ra と rb を同時に行う。

rra (reverse rotate a): スタック a の全要素を 1 つ下へシフトします。
最後の要素が最初の要素になる。

rrb (reverse rotate b): スタック b の全要素を 1 つ下へシフトする。
最後の要素が最初の要素になる。

rrr : rra と rrb を同時に行う。



## 道筋

1,スタックを作成する。

2,スタックをソートするための命令群を作る。

3,ソートする。


##　ファイルの構成例

コーディング開始時に「最初に書くべきもの」

「何を書けばいいか分からない」を潰すために、最初のファイル構成の例を置きます。

parse.c：argv → int配列/リスト、エラーチェック

stack.c：スタック基本操作（push/pop/size/last）

ops_swap.c：sa/sb/ss

ops_push.c：pa/pb

ops_rotate.c：ra/rb/rr

ops_rev_rotate.c：rra/rrb/rrr

debug.c：スタック表示（最初は必須）

small_sort.c：3個/5個用

main.c：流れだけ

最初は debug.c があるだけで理解速度が10倍になります。



##　今のところやらないといけないこと

次のステップ（ここまでできたら次に何？）

いまの段階で「Aが作れる」ようになったら、次に push_swap の必須要件として：

重複チェック

./push_swap "1 2 3" のようなクオート入力対応（split）

Error時は必ず “作ったものをfreeしてから” 終了

を入れていくのが最短ルートです。

かつ

次は「Aができた」前提で、いよいよ **操作（sa/pb/ra/rra）**に入れます。
どれから作りたいですか？（おすすめ順）

sa（先頭2つswap）

pb / pa（A↔Bへ移動）

ra / rra（回転）

あなたの理解を一気に固めるなら、pb → pa が「スタックっぽさ」が最も体感できます。