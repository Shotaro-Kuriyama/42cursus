# push_swapの概要

まず何をする？
→push_swapは、「限られた命令だけでスタックを並べ替える」アルゴリズム課題
整数列を、スタックaに積んで開始し、もう一つのスタックbは空とする。
用意された命令（sa/sb/ss/pa/pb/ra/rb/rr/rra/rrb/rrr）だけで、aを昇順に並べる。

じゃあスタックってなに？
スタックとはデータを積み上げるということである。
今回の場合は、整数列（21,312,1,5,4325235,2424,42）をスタックaに積み上げる
→大きな箱に一個一個データを入れていく
つまりスタックaは、言い換えればデータの構造であるということ。
よってスタックaの表現方法は一つに限らない。

## スタックの表現方法

まずスタックを視覚化すると以下のようになる。
a: [3, 1, 2]

ここから、「スタックである」ための条件は
1, データが繋がっている、または、連結されている。
２, 繋がっているデータは入れ替え可能である。

これらを満たす。
よって少なくとも以下の２つの表現方法がある。

### 1、配列
配列は
とあるメモリのアドレスを筆頭に**隣合わせでデータ（変数）**が連なる。
よって、データが連結されている。
このことから、繋がっているデータは入れ替え可能である。

### 2、連結リスト
連結リストは
あるメモリに格納されている一つのデータ（構造体）と、
更に別にあるメモリに格納されている一つのデータ（構造体）を
**一つのデータ群（構造体）＝ノード**という形で連結して持つことができる。
よってデータも入れ替え可能。

### 補足
この２つの違いはデータ構造がメモリを隣合わせで持つのか、飛び飛びのメモリから
それらをポインタを利用してデータ構造として連なるのか、という違いがある。
これが配列と連結リストの大きな違いである。



##　昇順に並べるということ＝ソート

では、「スタックaに積まれた整数列を昇順に並べよ」という問題は
どのように解くことができるか？
これはソートという超有名で重要な手法を用いる

ソートとは
**数値や文字列などのデータを、指定されたルール（基準）に従って昇順（小さい順）や降順（大きい順）などに並べ替える操作のことです。これは、データを効率的に検索・処理・表示するために不可欠な基本機能で、ソートアルゴリズム（バブルソート、クイックソートなど）を用いて実装され、多くのプログラミング言語で標準機能として提供されています。**

##　結論
以上から、
スタックaのデータを昇順に並べるためにはソートを用いる。
ただし、今回の課題は以下の２つの条件が存在する。

### 1、スタックb

◦ スタック a には、負の数と正の整数がランダムな個数含まれている。
◦ スタック b は空です。

### 2、ソートをするために使用できる命令は以下のものだけである。

sa (swap a): スタック a の先頭にある最初の 2 要素を入れ替える。
要素が1つしかない場合、または要素が存在しない場合は何もしない。

sb (swap b): スタック b の先頭にある最初の 2 要素を入れ替える。
要素が1つしかない場合、または要素が存在しない場合は何もしない。

ss : sa と sb を同時に行う。

pa (push a): b の先頭要素を取り、a の先頭に置く。
bが空の場合、何もしない。

pb (push b): a の先頭要素を取り、b の先頭に置く。
aが空の場合、何もしない。

ra (rotate a): スタック a の全要素を 1 つ上にシフトする。
最初の要素が最後の要素になる。

rb (rotate b): スタック b の全要素を 1 つ上にシフトします。
最初の要素が最後の要素になる。

rr : ra と rb を同時に行う。

rra (reverse rotate a): スタック a の全要素を 1 つ下へシフトします。
最後の要素が最初の要素になる。

rrb (reverse rotate b): スタック b の全要素を 1 つ下へシフトする。
最後の要素が最初の要素になる。

rrr : rra と rrb を同時に行う。



## 道筋

1,スタックを作成する。

2,スタックをソートするための命令群を作る。

3,ソートする。



## １、スタック作成

まず、大きな場合分けが２つ

#### パターン１
./push_swap 2 1 4 3

スタックa→[2, 1, 4, 3]

これはint argc = 5

となるときで、**argvが以下のような構造になるときである。
ただし、この図はヒープにmallocしている変数に入れることを前提としている。
argvは「OS/ランタイムが用意して渡してくれる、文字列ポインタ配列」
自分ではmallocしていない領域

(スタック)                          (ヒープ)
char **tokens  ───────────────▶  +---------------------------+
                                 | tokens[0] | tokens[1] | ...| tokens[n]=NULL |
                                 +----+-----------+--------+------------------+
                                      |           |
                                      v           v
                                  "2\0"      "1\0"     ...


#### パターン２
./push_swap "2 1" "3 5" 4 6 "9"

スタックa→[2, 1, 3, 5, 4, 6, 9]

これはint argc = 6

この場合の図は以下のようになる

(mainのスタックフレーム)
  argc = 6
  argv (char**)  ───────────────▶  argv配列（char*の配列, NULL終端）
                                  +------------------------------------+
                                  | argv[0] | argv[1] | ... | argv[5] | argv[6]=NULL |
                                  +----+--------+--------+------+-----+-------------+
                                       |        |        |      |     |
                                       v        v        v      v     v
                                   "./push_swap\0"
                                            "2 1\0"
                                                     "3 5\0"
                                                            "4\0"
                                                                 "6\0"
                                                                      "9\0"


パターン2において、argv[i] が "2 1" や "3 5" みたいに 複数入りが混ざる
→ だから各 argv[i] を さらに split して 数を取り出す

ここから、目的→戦略→手順→失敗時→結果の順に明確にしていく。



1. 目的（最終的に何を作るか）
コマンドライン引数に含まれる数字をすべて読み取り、
不正入力（空、非数、範囲外、重複）を弾き、
正しい整数だけを スタックA（連結リスト）に順番通りに積む。

2. 戦略（パターン1/2をどう統一するか）
引数の形式は2種類ある。
・パターン1：2 1 4 3 のように 1引数 = 1数
・パターン2："2 1" のように 1引数 = 複数数（空白区切り）
しかし今回は処理を分岐させず、すべての argv[i] を split してから処理することで統一できる。

1数なら split 結果は ["2", NULL]

複数なら ["2","1",NULL]

つまり、入力は最終的に「文字列トークン列（tokens）」へ正規化される。

3. 手順（外側ループ→内側ループ）
i = 1 から argc-1 まで各引数 argv[i] を順番に処理する（外側ループ）
それぞれを split_ws(argv[i]) で分割し tokens を得る
tokens[j] を先頭から順に見ていき（内側ループ）、
・厳密に int に変換できるか
・既にスタックAに同じ値がないか
・ノード作成に成功するか
を確認してから push_back で追加する

4. エラー条件と後始末（ここがpush_swapで超大事）
split_ws が失敗 → メモリ不足など → 今まで作ったリストも含めて解放して終了
tokens[0] がない（空白だけなど） → Error
数値変換が失敗（非数、オーバーフロー含む） → Error
重複がある → Error
ノード確保に失敗 → Error
正常時は free_split(tokens) を毎回行い、最後に free_list(a) で全解放する

まとめ
このプログラムは、コマンドライン引数から整数列を読み取り、スタックA（連結リスト）に積む。
入力形式には「各数字が別引数で渡される場合」と「1つの引数に空白区切りで複数数字が含まれる場合」があるが、両方を同じ処理で扱うために、argv[i] を毎回 split_ws で分割して tokens（文字列の配列）に正規化する。
外側ループで i=1 から argc-1 までの各引数を順に処理し、内側ループで tokens[j] を先頭から取り出して数値化する。
各トークンは parse_int_strict_by_atoi で厳密に int へ変換し、変換できない文字列・範囲外の値は Error とする。ささらに contains で重複を検出し、重複があれば Error とする。
問題ない値は new_node でノードを作って push_back でスタックAの末尾に追加する。
途中でエラーが起きた場合は、それまでに確保したリストや split の結果を解放して終了する。正常に処理できた場合は、スタックAには入力順に整数が積まれる。

この入力処理は「正規化 → 検証 → 構築」の3段階
正規化：split_ws(argv[i])
検証：parse_int_strict / contains
構築：new_node / push_back

2. スタックをソートするための命令群を作る。

これは本当二ただそのまま再現するだけ

##　ファイルの構成例

コーディング開始時に「最初に書くべきもの」

「何を書けばいいか分からない」を潰すために、最初のファイル構成の例を置きます。

parse.c：argv → int配列/リスト、エラーチェック

stack.c：スタック基本操作（push/pop/size/last）

ops_swap.c：sa/sb/ss

ops_push.c：pa/pb

ops_rotate.c：ra/rb/rr

ops_rev_rotate.c：rra/rrb/rrr

debug.c：スタック表示（最初は必須）

small_sort.c：3個/5個用

main.c：流れだけ

最初は debug.c があるだけで理解速度が10倍になります。



##　今のところやらないといけないこと

次のステップ（ここまでできたら次に何？）

いまの段階で「Aが作れる」ようになったら、次に push_swap の必須要件として：

重複チェック

./push_swap "1 2 3" のようなクオート入力対応（split）

Error時は必ず “作ったものをfreeしてから” 終了

を入れていくのが最短ルートです。

かつ

次は「Aができた」前提で、いよいよ **操作（sa/pb/ra/rra）**に入れます。
どれから作りたいですか？（おすすめ順）

sa（先頭2つswap）

pb / pa（A↔Bへ移動）

ra / rra（回転）

あなたの理解を一気に固めるなら、pb → pa が「スタックっぽさ」が最も体感できます。