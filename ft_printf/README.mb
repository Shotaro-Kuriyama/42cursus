まず、あなたの subject（このPDF）で“確定”している要件

関数名・目的：ft_printf(const char *fmt, ...) を作り、標準 printf の挙動に可能な限り一致させる（ただし内部バッファ管理は実装しない）。

対応する変換指定子（必須）：%c %s %p %d %i %u %x %X %%

外部関数の使用許可：malloc, free, write, va_start, va_arg, va_copy, va_end

libft：使用可。

成果物：libftprintf.a（ar で生成。libtoolは禁止）


実装のために必要な知識を“順番”に身につける

以下は学習→設計→実装の順で迷わないための導線です。各見出しは“知識の粒度”で並べています。

1) 可変長引数（stdarg.h）の基礎

用語：va_list / va_start / va_arg / va_end / va_copy の役割

デフォルト引数昇格：char/short → int、float → double

指定子ごとの取り出し型の対応：

%c→int、%s→char *、%p→void *、%d/%i→int、%u/%x/%X→unsigned int、%%は引数を消費しない

ここを理解しないと「取り出したのに値がおかしい」「落ちる」といった事故が起きます。

2) 出力の最小単位：write(1, &c, 1)

まずは1文字ずつ出すでOK（後で最適化したければ“塊で出す”）。

合計出力文字数を必ず数える（ft_printf の戻り値）。

write が負を返したら**以後はエラー扱い（-1を返す設計）**に統一。

3) 文字列フォーマットの“読み取り”＝パーサの素振り

fmt を先頭から走査：通常文字はそのまま出力、% を見たら“解析モード”へ。

必須だけなら：% の次の1文字が指定子かを判定して分岐すれば足りる。

ボーナスありなら：% → フラグ群（-0# + と . の有無）→ 幅（数字or*）→ 精度（.の後に数字or*）→ 指定子、という順に読む小さな構造体を用意。

4) 各指定子の正しい出力ルール（必須9種）

%c：1文字（'\0' も1文字としてカウント）

%s：ヌル終端まで出力。ポインタがNULLなら 慣習的に "(null)"（42系ではよく求められる）

%p：0x + 16進小文字のアドレス。NULLは(nil)（42では標準的）

%d/%i：符号付き10進。INT_MIN（-2147483648）の扱いに注意

%u：符号なし10進

%x/%X：符号なし16進（小文字／大文字）

%%：パーセント記号そのもの

ここでは幅・精度・フラグなしの“素の出力”を完璧にするのが先。次にパディング等を足します。

5) 数値→文字列の変換ロジック

10進/16進の桁生成は「割って余りを逆順に貯める→ひっくり返す」が基本。

unsigned による処理の方が桁生成が簡単（負号は別管理）。

INT_MIN など境界値は“符号と本体の分離”を徹底。


6)（ボーナス）幅・精度・フラグの“適用順序”

混乱しやすいのでパイプライン思考で固定化：

本体文字列（例：数値の絶対値を文字列化／%sなら元文字列）

精度

整数：最低桁数を0で左側パディング

文字列：最大文字数で切り詰め

整数で精度指定があれば 0 フラグは無効

接頭辞・符号（-、+、スペース、0x/0X）を本体の前へ

幅

右寄せ（デフォルト）or 左寄せ（-）

空白 or 0 で埋める（ただし精度指定時の整数は0無効）

ゼロ特例：整数で「値0 × 精度0」→ 出力は空（でも幅は効く）

#：%x/%X で値が0以外なら 0x/0X を付与

+ vs スペース：正数での表示、+ が優先

*：幅/精度を引数から読む（幅が負なら - フラグ＋幅は正に、精度が負なら“未指定”扱い）

7) 設計の分割（ファイル・関数の責務）

ft_printf.c：メインループ（走査・ディスパッチ・合計文字数管理）

parse.c：フラグ／幅／精度／指定子の読み取り

print_char.c / print_str.c / print_ptr.c / print_int.c / print_uint_hex.c：指定子ごとの“素の”出力

format_apply.c：精度・接頭辞・幅の適用（段階別の小関数に）

utoa_base.c：unsigned→任意基数文字列化（大/小文字切替）

out.c：writeラッパ（出力＋カウント＋エラー伝播）

42 Norm を守るには、小さく分けてネストを浅くするのがコツ。

8) Makefile と成果物の要件

ルール：NAME, all, clean, fclean, re を備える

フラグ：-Wall -Wextra -Werror、コンパイラは cc

アーカイブ：ar を使い libftprintf.a をリポジトリ直下に作る（libtoolは禁止）

libft を使うなら libft/ 下にソースとMakefileを置き、親のMakefileからビルド連携
（いずれも Common/Mandatory の章参照）


“迷いにくい”実装順ロードマップ（演習課題つき・ノーコード）

Phase A（必須コア）

writeラッパ＋合計文字数の管理（失敗時のエラー状態を用意）

%c %s %d/%i %u %x/%X %% を素の出力のみで通す

テスト：'\0' を %c で出す（見えないがカウント+1）

%s に NULL → "(null)"

INT_MIN/INT_MAX/0/-1、UINT_MAX、0x0 など境界

%p（0x + 16進小文字、NULL は (nil)）

Phase B（ボーナス基礎）
4) 幅（右寄せ）→ 左寄せ- → 0埋め0（整数の精度指定時は無効ルールに注意）
5) 精度（整数のゼロ埋め／文字列切り詰め／値0×精度0=出力空）
6) + と スペース（正数の符号表示、優先順位）
7) #（0値時は抑制）
8) *（引数から幅・精度取得、負値の扱い）

Phase C（最終確認）
9) 仕様の相互作用（-と0同時、#と幅、精度と0埋め…）をケース表で総当り
10) write失敗の**-1伝播**／リークなし（基本はヒープを避けつつ、使う場合はfreeの位置を明確化）
11) Makefile・libftprintf.a・提出物の形を最終チェック


テスト観点チェックリスト（自作でOK）

戻り値：出力文字数が合っているか（printf と突き合わせ）

境界：%cで'\0'、%sでNULL/""/長文、%pでNULL/非NULL

数値：INT_MIN/INT_MAX/0/-1、UINT_MAX、0x 系の端

ボーナス：

幅：小/大、左寄せ、0埋め

精度：整数（桁不足の0追加／0×精度0→空）、文字列（切り詰め）

# +（スペース含む）：0時の#抑制、+優先

*：幅負値→-化／精度負値→未指定

よくある詰まりポイント → 先に考え方を固定

「何をいつ付ける？」問題

本体（符号抜き／接頭辞抜き）

精度（整数は左0追加／文字列は切り詰め）

接頭辞・符号（-/+/スペース/0x）

幅（左/右、空白or0）
→ この順を守ると、-0x001a のような接頭辞位置や0の入り方が自然に正しくなる。

INT_MIN は“そのまま絶対値にすると壊れる”→負号フラグと本体unsigned化で回避。

%s の NULL と %p の NULL を必ず仕様どおりに（テスターがよく突く）。

writeの失敗は全系統で -1 を返せる設計にしておく（途中で失敗しても合流して返す）。

最短学習プラン（初心者向け）

可変長引数をメモにまとめ、%c/%s/%dの型対応を暗記

素の出力だけで必須9指定子を動かす（幅・精度・フラグはまだ無視）

数値変換の固定手順を言語化（“余りを逆順に貯めて反転”）

適用順序パイプラインを紙に図解（本体→精度→接頭辞→幅）

ボーナスを1個ずつ追加し、各追加で10ケースほど手で検証

すべて揃ったら相互作用（競合）を表にして総当り